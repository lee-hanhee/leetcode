\begin{algo}
\begin{lstlisting}
def binary_search(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2

        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1
\end{lstlisting}
\end{algo}

\subsection{When to Use?}
\begin{summary}
    \begin{itemize}
        \item Use when the input is \textbf{sorted} or can be \textbf{monotonically mapped}.
        \item Common for problems involving \textbf{searching for a target}, \textbf{finding boundaries}, or \textbf{min/max constraints}.
        \item Works on arrays, answer ranges, or implicit search spaces with $\mathcal{O}(\log n)$ complexity.
    \end{itemize}
\end{summary}
\newpage

\subsubsection{Common Problems}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problems} & \textbf{Description} \\
            \midrule
            704. Binary Search & Given a sorted array of integers, return the index of the target. \\
            & If not found, return -1. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Implement binary search.
                \end{itemize}
            } \\
            \midrule
            74. Search a 2D Matrix & Given a 2D matrix, search for a target value. \\
            & If found, return its index. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Use binary search to find the row by comparing first value of mid row < target (decrement bottom) \& last value of mid row < target (increment top).
                    \item Row is top + bottom // 2.
                    \item Then, use binary search to find the column in that row.
                \end{itemize}
            } \\
            \midrule
            875. Koko Eating Bananas & Given an array of piles and an integer h, \\
            & find the minimum eating speed k such that Koko can eat all bananas in h hours. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Use binary search to find the minimum k w/ l = 0, r = max(piles) since k must be in this range.
                    \item Check if k is valid by calculating the total hours needed to eat all bananas.
                    \begin{itemize}
                        \item for p in piles total\_hours += math.ceil(p / k)
                        \item Compare total\_hours with h. If hours <= h, update r = mid - 1 and res = mid. Else update l = mid + 1.
                    \end{itemize}
                \end{itemize}
            } \\
            \midrule 
            153. Find Minimum in Rotated Sorted Array & Given a rotated sorted array, find the minimum element. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Store res. 
                    \item Initialize l = 0, r = len(nums) - 1.
                    \item While l <= r:
                    \begin{itemize}
                        \item If nums[l] < nums[r], res = min(res, nums[l]) and break. This means the array is not rotated.
                        \item Else, get the mid and update res = min(res, nums[mid]). If nums[mid] >= nums[l], update l = mid + 1 (i.e. min is in the right half). Else, update r = mid - 1 (i.e. min is in the left half).
                    \end{itemize}
                \end{itemize}
            } \\
            \midrule
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
