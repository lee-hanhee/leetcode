\subsection{When to Use?}
\begin{summary}
    \begin{itemize}
        \item To count frequencies in \( O(n) \) time.
        \item To check membership in constant time.
        \item To map keys to values (e.g., index, count, group).
        \item To group elements by shared features (e.g., anagrams).
        \item To detect duplicates efficiently.
    \end{itemize}
\end{summary}

\subsection{Hashing}
\begin{algo}
\begin{lstlisting}
def solve_problem(nums):
    # Step 1: Initialize the hashmap (e.g., for frequency, index, or existence check)
    hashmap = {}

    # Step 2: Iterate over the array
    for i, num in enumerate(nums):
        # Step 3: Define your condition (e.g., check complement, existence, frequency)
        if some_condition_based_on_hashmap(num, hashmap):
            # Step 4: Return or process result as needed
            return result_based_on_condition
        
        # Step 5: Update the hashmap
        hashmap_update_logic(num, i, hashmap)

    # Step 6: Handle the case where the condition is never met
    return final_result_if_needed

# Helper functions (replace with actual logic based on the problem)
def some_condition_based_on_hashmap(num, hashmap):
    # Example: return (target - num) in hashmap
    pass

def hashmap_update_logic(num, i, hashmap):
    # Example: hashmap[num] = i
    pass
\end{lstlisting}
\end{algo}
\newpage

\subsection{Common Problems}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            \midrule
            217. Contains Duplicate & Given an integer array nums, return true if any value appears at least twice. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Use a set to store the elements. If an element is already in the set, return True.
                    \item Otherwise, add it to the set.
                \end{itemize}
            } \\
            \midrule
            242. Valid Anagram & Given two strings s and t, return true if t is an anagram of s and false otherwise. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Use a hashMap to count the frequency of each character in s and t.
                    \item If the frequency maps are equal, return True. Otherwise, return False.
                \end{itemize}
            } \\
            \midrule
            1. Two Sum & Given an array of integers, return indices of the two numbers s.t. \\
            & they add up to a specific target. \\            
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item \textbf{Tricks:}
                    \begin{itemize}
                        \item Use a hashMap to store the indices of the elements, \texttt{prevMap[nums[i]] = i}
                        \item For each element, check if the target - nums[i] is in the map.
                        \item If it is, return the index of the target - nums[i] (from prevMap) and i. Otherwise, add target - nums[i].
                    \end{itemize}
                \end{itemize}
            } \\
            \midrule
            **49. Group Anagrams & Given an array of strings, group the anagrams together. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Use a hashMap to store a tuple of count of each char as the key and the list of words as the value.
                    \item For each word, create a tuple of count of each char and add the word to the list in the map.
                    \item Finally, return the values of the map.
                \end{itemize}
            } \\
            \midrule
            **347. Top K Frequent Elements & Given an integer array nums and an integer k, \\
            & return the k most frequent elements. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Use a hashMap to count the frequency of each element.
                    \item Sort the map by frequency and return the top k elements.
                \end{itemize}
            } \\
            \midrule
            118. Pascal's Triangle & Given an integer numRows, return the first numRows of Pascal's triangle. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item \textbf{Initialize:} \texttt{res = [[1]]}.
                    \item \textbf{Loop from numRows - 1:}
                    \begin{itemize}
                        \item \textbf{Pad the PrevRow:} Create \texttt{dummy\_row} by padding the last row in \texttt{res} with zeros at both ends. 
                        \item \textbf{Loop 2 from len(prevRow) + 1:} For each position \texttt{i}, compute the value \texttt{dummy\_row[i] + dummy\_row[i+1]} and append it to the new row. 
                    \end{itemize}
                \end{itemize}                
            } \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
\newpage

\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            73. Set Matrix Zeroes & Given an m x n integer matrix, if an element is 0, \\
            & set its entire row and column to 0. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}                
                    \item \textbf{Record Zero Positions:} Iterate through all elements. If \texttt{matrix[i][j] == 0}, append \texttt{[i, j]} to list.
                    \item \textbf{Row/Column Zeroing:} Set all elements in column \texttt{col\_ind} to zero and all elements in row \texttt{row\_ind} to zero using two helpers.
                \end{itemize}                
            } \\
            \midrule
            54. Spiral Matrix & Given an m x n matrix, return all elements of the matrix in spiral order. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item \textbf{Initialize:} Create an empty list \texttt{res} and set boundaries: \texttt{top, bottom, left, right}.
                    \item \textbf{Loop:} While top <= bottom and left <= right. Use helper functions to achieve the following:
                    \begin{itemize}
                        \item Traverse from left to right along the top row.
                        \item Traverse from top to bottom along the right column.
                        \item Traverse from right to left along the bottom row.
                        \item Traverse from bottom to top along the left column.
                    \end{itemize}
                \end{itemize}
            } \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}

