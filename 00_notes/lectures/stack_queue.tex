\subsection{collections.deque}
\begin{summary}
\begin{lstlisting}
from collections import deque
\end{lstlisting}

\begin{lstlisting}
deque(iterable=None, maxlen=None)
\end{lstlisting}
\begin{itemize}
    \item Creates a new deque object initialized with elements from \texttt{iterable}.
    \item \textbf{Arguments:} \texttt{iterable}: optional iterable of elements; \texttt{maxlen}: maximum number of elements.
\end{itemize}

\begin{lstlisting}
d.append(x)
\end{lstlisting}
\begin{itemize}
    \item Adds \texttt{x} to the right end of the deque.
    \item \textbf{Arguments:} \texttt{x}: element to append.
\end{itemize}

\begin{lstlisting}
d.appendleft(x)
\end{lstlisting}
\begin{itemize}
    \item Adds \texttt{x} to the left end of the deque.
    \item \textbf{Arguments:} \texttt{x}: element to append.
\end{itemize}

\begin{lstlisting}
d.pop()
\end{lstlisting}
\begin{itemize}
    \item Removes and returns the rightmost element.
    \item \textbf{Raises:} \texttt{IndexError} if deque is empty.
\end{itemize}

\begin{lstlisting}
d.popleft()
\end{lstlisting}
\begin{itemize}
    \item Removes and returns the leftmost element.
    \item \textbf{Raises:} \texttt{IndexError} if deque is empty.
\end{itemize}

\begin{lstlisting}
d.extend(iterable)
\end{lstlisting}
\begin{itemize}
    \item Appends elements from \texttt{iterable} to the right side.
    \item \textbf{Arguments:} \texttt{iterable}: iterable of elements to append.
\end{itemize}

\begin{lstlisting}
d.extendleft(iterable)
\end{lstlisting}
\begin{itemize}
    \item Appends elements from \texttt{iterable} to the left side (in reverse order).
    \item \textbf{Arguments:} \texttt{iterable}: iterable of elements to append.
\end{itemize}

\begin{lstlisting}
d.rotate(n=1)
\end{lstlisting}
\begin{itemize}
    \item Rotates the deque \texttt{n} steps to the right (left if negative).
    \item \textbf{Arguments:} \texttt{n}: number of steps to rotate.
\end{itemize}

\begin{lstlisting}
d.clear()
\end{lstlisting}
\begin{itemize}
    \item Removes all elements from the deque.
    \item \textbf{Postcondition:} deque is empty.
\end{itemize}

\begin{lstlisting}
d.count(x)
\end{lstlisting}
\begin{itemize}
    \item Counts occurrences of \texttt{x} in the deque.
    \item \textbf{Arguments:} \texttt{x}: element to count.
\end{itemize}

\begin{lstlisting}
d.remove(value)
\end{lstlisting}
\begin{itemize}
    \item Removes the first occurrence of \texttt{value}.
    \item \textbf{Raises:} \texttt{ValueError} if value is not present.
\end{itemize}

\end{summary}
\newpage

\subsection{Stack}
\begin{summary}
    Data structure that follows Last-In-First-Out (LIFO) order for inserting and removing elements.
    \begin{itemize}
        \item \textbf{Array or Linked List:} Used to maintain the linear order of elements.
        \item \textbf{Top Pointer:} Points to the most recently inserted element.
    \end{itemize}    
\end{summary}

\subsubsection{When to Use?}
\begin{summary}
    \begin{itemize}
        \item Function call management using a call stack.
        \item Reversing sequences or backtracking algorithms.
        \item Syntax parsing and expression evaluation.
    \end{itemize}
\end{summary}

\subsubsection{Operations}
\begin{summary}
    \begin{center}
        \begin{tabular}{lc}
            \toprule
            \textbf{Operation} & \textbf{Time Complexity (WC)} \\
            \midrule
            Push   & $O(1)$ \\
            Pop    & $O(1)$ \\
            Peek   & $O(1)$ \\
            IsEmpty & $O(1)$ \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}

\begin{algo}
\begin{lstlisting}[language=Python]
class Stack:
    def __init__(self):
        self.items = []  # Internal array to store elements

    def push(self, item):
        self.items.append(item)  # Add item to top

    def pop(self):
        if not self.is_empty():
            return self.items.pop()  # Remove and return top element

    def peek(self):
        if not self.is_empty():
            return self.items[-1]  # Return top element without removing

    def is_empty(self):
        return len(self.items) == 0
\end{lstlisting}
\end{algo}
\newpage

\subsection{Queue}
\begin{summary}
    Data structure that follows First-In-First-Out (FIFO) order for inserting and removing elements.
    \begin{itemize}
        \item \textbf{Array or Linked List:} Used to store elements in sequence.
        \item \textbf{Front and Rear Pointers:} Track the ends for dequeue and enqueue operations.
    \end{itemize}    
\end{summary}

\subsubsection{When to Use?}
\begin{summary}
    \begin{itemize}
        \item Scheduling processes in operating systems.
        \item Handling asynchronous data (e.g., IO Buffers, Event Queues).
        \item Breadth-First Search in graphs or trees.
    \end{itemize}
\end{summary}

\subsubsection{Operations}
\begin{summary}
    \begin{center}
        \begin{tabular}{lc}
            \toprule
            \textbf{Operation} & \textbf{Time Complexity (WC)} \\
            \midrule
            Enqueue  & $O(1)$ \\
            Dequeue  & $O(n)$ \\
            Peek     & $O(1)$ \\
            IsEmpty  & $O(1)$ \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}

\begin{algo}
\begin{lstlisting}
class Queue:
    def __init__(self):
        self.items = []  # Internal array to store elements

    def enqueue(self, item):
        self.items.append(item)  # Add item to the rear

    def dequeue(self):
        if not self.is_empty():
            return self.items.pop(0)  # Remove and return the front element

    def peek(self):
        if not self.is_empty():
            return self.items[0]  # Return front element without removing

    def is_empty(self):
        return len(self.items) == 0
\end{lstlisting}
\end{algo}