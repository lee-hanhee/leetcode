\subsection{Stack}
\begin{summary}
    Data structure that follows Last-In-First-Out (LIFO) order for inserting and removing elements.
    \begin{itemize}
        \item \textbf{Array or Linked List:} Used to maintain the linear order of elements.
        \item \textbf{Top Pointer:} Points to the most recently inserted element.
    \end{itemize}    
\end{summary}

\subsubsection{When to Use?}
\begin{summary}
    \begin{itemize}
        \item Function call management using a call stack.
        \item Reversing sequences or backtracking algorithms.
        \item Syntax parsing and expression evaluation.
    \end{itemize}
\end{summary}

\subsubsection{Operations}
\begin{summary}
    \begin{center}
        \begin{tabular}{lc}
            \toprule
            \textbf{Operation} & \textbf{Time Complexity (WC)} \\
            \midrule
            Push   & $O(1)$ \\
            Pop    & $O(1)$ \\
            Peek   & $O(1)$ \\
            IsEmpty & $O(1)$ \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}

\begin{algo}
\begin{lstlisting}[language=Python]
class Stack:
    def __init__(self):
        self.items = []  # Internal array to store elements

    def push(self, item):
        self.items.append(item)  # Add item to top

    def pop(self):
        if not self.is_empty():
            return self.items.pop()  # Remove and return top element

    def peek(self):
        if not self.is_empty():
            return self.items[-1]  # Return top element without removing

    def is_empty(self):
        return len(self.items) == 0
\end{lstlisting}
\end{algo}
\newpage

\subsection{Queue}
\begin{summary}
    Data structure that follows First-In-First-Out (FIFO) order for inserting and removing elements.
    \begin{itemize}
        \item \textbf{Array or Linked List:} Used to store elements in sequence.
        \item \textbf{Front and Rear Pointers:} Track the ends for dequeue and enqueue operations.
    \end{itemize}    
\end{summary}

\subsubsection{When to Use?}
\begin{summary}
    \begin{itemize}
        \item Scheduling processes in operating systems.
        \item Handling asynchronous data (e.g., IO Buffers, Event Queues).
        \item Breadth-First Search in graphs or trees.
    \end{itemize}
\end{summary}

\subsubsection{Operations}
\begin{summary}
    \begin{center}
        \begin{tabular}{lc}
            \toprule
            \textbf{Operation} & \textbf{Time Complexity (WC)} \\
            \midrule
            Enqueue  & $O(1)$ \\
            Dequeue  & $O(n)$ \\
            Peek     & $O(1)$ \\
            IsEmpty  & $O(1)$ \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}

\begin{algo}
\begin{lstlisting}
class Queue:
    def __init__(self):
        self.items = []  # Internal array to store elements

    def enqueue(self, item):
        self.items.append(item)  # Add item to the rear

    def dequeue(self):
        if not self.is_empty():
            return self.items.pop(0)  # Remove and return the front element

    def peek(self):
        if not self.is_empty():
            return self.items[0]  # Return front element without removing

    def is_empty(self):
        return len(self.items) == 0
\end{lstlisting}
\end{algo}