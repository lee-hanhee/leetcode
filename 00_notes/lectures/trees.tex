\subsection{Binary Search Tree (BST)}
\begin{summary}
    \begin{itemize}
        \item A binary tree where for each node, left subtree values are smaller, and right subtree values are larger.
        \item \textbf{Balanced vs. Unbalanced:} 
            \begin{equation*}
                O(\log (n)) \; \text{(balanced)} \leq O(h) \leq O(n) \; \text{(unbalanced)}
            \end{equation*}
        \item \textbf{In-order (Increasing order)}: Visit the left subtree, then the root, and finally the right subtree.
        \item \textbf{Pre-order}: Visit the root first, then the left subtree, and finally the right subtree.
        \item \textbf{Post-order}: Visit the left subtree, then the right subtree, and finally the root.
    \end{itemize}
\end{summary}

\begin{algo}
\begin{lstlisting}
class Node:
    def __init__(self, key):
        self.val = key
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def operations(self,_):
        pass
\end{lstlisting}
\end{algo}

\newpage

\subsection{Operations}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Operation} & \textbf{Time Complexity} \\
            \midrule
            Search & $O(h)$ \\
            \midrule
            Insert & $O(h)$ \\
            \midrule
            Delete & $O(h)$ \\
            \midrule
            Find Min/Max & $O(h)$ \\
            \midrule
            In-order Traversal & $O(n)$ \\
        \end{tabular}
    \end{center}
\end{summary}

\begin{algo}
\begin{lstlisting}
def search(self, key):
    current = self.root
    while current:
        if key == current.val:
            return current
        elif key < current.val:
            current = current.left
        else:
            current = current.right
    return None
\end{lstlisting}
\end{algo}

\begin{algo}
\begin{lstlisting}
def insert(self, key):
    def _insert(node, key):
        if node is None:
            return TreeNode(key)
        if key < node.val:
            node.left = _insert(node.left, key)
        elif key > node.val:
            node.right = _insert(node.right, key)
        return node
    self.root = _insert(self.root, key)
\end{lstlisting}
\end{algo}

\begin{algo}
\begin{lstlisting}
def delete(self, key):
    def _delete(node, key):
        if node is None:
            return None
        if key < node.val:
            node.left = _delete(node.left, key)
        elif key > node.val:
            node.right = _delete(node.right, key)
        else:
            # Node with one child or no child
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            # Node with two children
            temp = self._find_min(node.right)
            node.val = temp.val
            node.right = _delete(node.right, temp.val)
        return node
    self.root = _delete(self.root, key)
\end{lstlisting}
\end{algo}
    
\begin{algo}
\begin{lstlisting}
def _find_min(self, node):
    while node.left is not None:
        node = node.left
    return node
\end{lstlisting}
\end{algo}

\begin{algo}
\begin{lstlisting}
def inorder(self):
    def _inorder(node):
        if node:
            _inorder(node.left)
            print(node.val, end=' ')
            _inorder(node.right)
    _inorder(self.root)
\end{lstlisting}
\end{algo}    
\newpage

\subsubsection{Common Problems}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            226. Invert Binary Tree & Given a binary tree, invert it. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Base case: If the node is None, return.
                    \item Swap left and right children of the current node.
                    \item Recursively call the function on left and right children.
                \end{itemize}
            } \\
            \midrule
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}

\newpage

\subsubsection{BST-based Sets and Maps}

\begin{summary}
    \begin{itemize}
        \item \textbf{BST Set}: Stores unique values in sorted order. Supports insert, search, delete.
        \item \textbf{BST Map}: Associates keys with values, maintaining keys in sorted order.
        \item Can be implemented using self-balancing trees (e.g., AVL, Red-Black Tree) for O(log n) operations.
        \item Useful for range queries, floor/ceiling lookups, and ordered iteration.
    \end{itemize}
\end{summary}

\begin{algo}
\begin{lstlisting}
class BSTSet:
    def __init__(self):
        self.root = None

    def add(self, val):
        self.root = insert_bst(self.root, val)

    def contains(self, val):
        return search_bst(self.root, val) is not None

    def remove(self, val):
        self.root = delete_bst(self.root, val)

class BSTMap:
    def __init__(self):
        self.root = None

    def put(self, key, value):
        self.root = self._put(self.root, key, value)

    def _put(self, node, key, value):
        if not node:
            return TreeNode((key, value))
        if key < node.val[0]:
            node.left = self._put(node.left, key, value)
        elif key > node.val[0]:
            node.right = self._put(node.right, key, value)
        else:
            node.val = (key, value)
        return node

    def get(self, key):
        node = self.root
        while node:
            if key < node.val[0]:
                node = node.left
            elif key > node.val[0]:
                node = node.right
            else:
                return node.val[1]
        return None
\end{lstlisting}
\end{algo}

\newpage


\subsection{Breadth-First Search (BFS)}
\begin{summary}
    \begin{itemize}
        \item Use when exploring nodes layer-by-layer, typically in unweighted graphs or grids.
        \item Ideal for finding the shortest path, level order traversal, or minimum number of steps.
        \item Queue-based traversal ensures nodes are visited in order of increasing distance from the source.
    \end{itemize}
\end{summary}

\begin{algo}
\begin{lstlisting}
from collections import deque

def bfs(start, graph):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        node = queue.popleft() # FIFO (BFS)

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
\end{lstlisting}
\end{algo}
\newpage

\subsubsection{Common Problems}
\begin{summary}
\end{summary}
\newpage

\subsection{Depth-First Search (DFS)}

\begin{summary}
    \begin{itemize}
        \item Use when traversing all nodes or paths in \textbf{trees}, \textbf{graphs}, or \textbf{matrices}.
        \item Ideal for problems involving \textbf{backtracking}, \textbf{recursion}, or exploring all \textbf{connected components}.
        \item Can be implemented recursively or iteratively with a stack.
        \item Maintain a \texttt{visited} set or matrix to avoid revisiting nodes.
        \item Useful for \textbf{topological sorting}, \textbf{cycle detection}, and \textbf{pathfinding}.
    \end{itemize}
\end{summary}

\begin{algo}
\begin{lstlisting}
from collections import deque

def dfs(start, graph):
    visited = set()
    stack = deque([start])
    visited.add(start)

    while stack:
        node = stack.pop()  # LIFO (DFS)

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                stack.append(neighbor) 
\end{lstlisting}
    \end{algo}

\begin{algo}
\begin{lstlisting}
def dfs(node, visited):
    if node in visited:
        return

    visited.add(node)

    for neighbor in graph[node]:
        dfs(neighbor, visited)
\end{lstlisting}
\end{algo}

\newpage

\subsubsection{Common Problems}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            \midrule
            200. Number of Islands & Given a 2D grid of '1's (land) and '0's (water), count the number of islands. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Use DFS or BFS to explore all connected '1's and mark them as visited.
                    \item Increment the island count for each unvisited '1'.
                \end{itemize}
            } \\
            \midrule
            79. Word Search & Given a 2D board and a word, check if the word exists in the grid. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Use DFS to explore all possible paths in the grid.
                    \item Mark cells as visited to avoid revisiting.
                    \item Backtrack if the current path does not lead to a solution.
                \end{itemize}
            } \\
        \end{tabular}
    \end{center}
\end{summary}