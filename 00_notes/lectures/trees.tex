\subsection{Binary Search Tree (BST)}
\begin{summary}
    \begin{itemize}
        \item A binary tree where for each node, left subtree values are smaller, and right subtree values are larger.
        \item \textbf{Balanced vs. Unbalanced:} 
            \begin{equation*}
                O(\log (n)) \; \text{(balanced)} \leq O(h) \leq O(n) \; \text{(unbalanced)}
            \end{equation*}
    \end{itemize}
\end{summary}

\begin{algo}
\begin{lstlisting}
class Node:
    def __init__(self, key):
        self.val = key
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def operations(self,_):
        pass
\end{lstlisting}
\end{algo}

\subsection{In-order, Pre-order, Post-order Traversal}
\begin{definition}
    \begin{itemize}
        \item \textbf{In-order (Left → Root → Right)}: Visit the left subtree, then the root, and finally the right subtree.
        \begin{itemize}
            \item Used for retrieving elements in sorted order from a BST.5
        \end{itemize}
        \item \textbf{Pre-order (Root → Left → Right)}: Visit the root first, then the left subtree, and finally the right subtree.
        \begin{itemize}
            \item Useful for copying or serializing the tree.
        \end{itemize}
        \item \textbf{Post-order (Left → Right → Root)}: Visit the left subtree, then the right subtree, and finally the root.
        \begin{itemize}
            \item Useful for deleting or freeing nodes in memory.
        \end{itemize}
    \end{itemize}
\end{definition}

\newpage

\subsection{Operations}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Operation} & \textbf{Time Complexity} \\
            \midrule
            Search & $O(h)$ \\
            \midrule
            Insert & $O(h)$ \\
            \midrule
            Delete & $O(h)$ \\
            \midrule
            Find Min/Max & $O(h)$ \\
            \midrule
            In-order Traversal & $O(n)$ \\
        \end{tabular}
    \end{center}
\end{summary}

\begin{algo}
\begin{lstlisting}
def search(self, key):
    current = self.root
    while current:
        if key == current.val:
            return current
        elif key < current.val:
            current = current.left
        else:
            current = current.right
    return None
\end{lstlisting}
\end{algo}

\begin{algo}
\begin{lstlisting}
def insert(self, key):
    def _insert(node, key):
        if node is None:
            return TreeNode(key)
        if key < node.val:
            node.left = _insert(node.left, key)
        elif key > node.val:
            node.right = _insert(node.right, key)
        return node
    self.root = _insert(self.root, key)
\end{lstlisting}
\end{algo}

\begin{algo}
\begin{lstlisting}
def delete(self, key):
    def _delete(node, key):
        if node is None:
            return None
        if key < node.val:
            node.left = _delete(node.left, key)
        elif key > node.val:
            node.right = _delete(node.right, key)
        else:
            # Node with one child or no child
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            # Node with two children
            temp = self._find_min(node.right)
            node.val = temp.val
            node.right = _delete(node.right, temp.val)
        return node
    self.root = _delete(self.root, key)
\end{lstlisting}
\end{algo}
    
\begin{algo}
\begin{lstlisting}
def _find_min(self, node):
    while node.left is not None:
        node = node.left
    return node
\end{lstlisting}
\end{algo}

\begin{algo}
\begin{lstlisting}
def inorder(self):
    def _inorder(node):
        if node:
            _inorder(node.left)
            print(node.val, end=' ')
            _inorder(node.right)
    _inorder(self.root)
\end{lstlisting}
\end{algo}    
\newpage

\subsubsection{Common Problems}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            **226. Invert Binary Tree & Given a binary tree, invert it. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Base case: If the node is None, return.
                    \item Swap left and right children of the current node.
                    \item Recursively call the function on left and right children.
                \end{itemize}
            } \\
            \midrule
            **104. Maximum Depth of Binary Tree & Given a binary tree, find its maximum depth. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item \textbf{Recursive DFS:}
                    \begin{itemize}
                        \item Base case: If the node is None, return 0.
                        \item Recursively find the maximum depth of left and right subtrees.
                        \item Return the maximum of the two depths plus one for the current node.
                    \end{itemize}
                    \item \textbf{Iterative BFS:}
                    \begin{itemize}
                        \item Initialize an empty queue $q$.
                        \item Append $root$ to $q$ and set $level \gets 0$ unless root is None.
                        \item While $q$ is not empty:
                        \begin{itemize}
                            \item For each node in the current level (\texttt{len(q)} iterations):
                            \begin{itemize}
                                \item Pop the front node from $q$.
                                \item If the node has a left child, append it to $q$.
                                \item If the node has a right child, append it to $q$.
                            \end{itemize}
                            \item Increment $level$ after processing all nodes in the current level.
                        \end{itemize}
                        \item Return $level$ as the maximum depth of the tree.
                    \end{itemize}                    
                \end{itemize}
            } \\
            \midrule
            **543. Diameter of Binary Tree & Given a binary tree, find its diameter. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item The diameter is the longest path between any two nodes in the tree.
                    \item Use DFS to calculate the height of each subtree and update the diameter.
                    \item The diameter at each node is the sum of the heights of its left and right subtrees.
                \end{itemize}
            } \\
            \midrule

            \midrule
            110. Balanced Binary Tree & Given a binary tree, check if it is height-balanced. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item A tree is balanced if the heights of the two child subtrees of any node differ by no more than one.
                    \item Use DFS to calculate the height of each subtree and check the balance condition.
                \end{itemize}
            } \\
            \midrule
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
\newpage

\subsubsection{BST-based Sets and Maps}

\begin{summary}
    \begin{itemize}
        \item \textbf{BST Set}: Stores unique values in sorted order. Supports insert, search, delete.
        \item \textbf{BST Map}: Associates keys with values, maintaining keys in sorted order.
        \item Can be implemented using self-balancing trees (e.g., AVL, Red-Black Tree) for O(log n) operations.
        \item Useful for range queries, floor/ceiling lookups, and ordered iteration.
    \end{itemize}
\end{summary}

\begin{algo}
\begin{lstlisting}
class BSTSet:
    def __init__(self):
        self.root = None

    def add(self, val):
        self.root = insert_bst(self.root, val)

    def contains(self, val):
        return search_bst(self.root, val) is not None

    def remove(self, val):
        self.root = delete_bst(self.root, val)

class BSTMap:
    def __init__(self):
        self.root = None

    def put(self, key, value):
        self.root = self._put(self.root, key, value)

    def _put(self, node, key, value):
        if not node:
            return TreeNode((key, value))
        if key < node.val[0]:
            node.left = self._put(node.left, key, value)
        elif key > node.val[0]:
            node.right = self._put(node.right, key, value)
        else:
            node.val = (key, value)
        return node

    def get(self, key):
        node = self.root
        while node:
            if key < node.val[0]:
                node = node.left
            elif key > node.val[0]:
                node = node.right
            else:
                return node.val[1]
        return None
\end{lstlisting}
\end{algo}