\subsection{Heap}
\begin{summary}
    \begin{itemize}
        \item \textbf{Max heap:} Largest key at root, where every parent node is \textbf{greater than or equal to} its children.
        \item \textbf{Min heap:} Smallest key at root, where every parent node is \textbf{less than or equal to} its children.
        \item \textbf{Balanced Tree:} $h=\log n$
        \item \textbf{Indexing:} Given a node at index $i$ in the array:
        \begin{enumerate}
            \item \textbf{Parent:} $\text{parent(i)} = \left \lfloor \frac{i}{2} \right \rfloor$
            \item \textbf{Left child:} $\text{leftchild(i)} = 2i$
            \item \textbf{Right child:} $\text{rightchild(i)} = 2i+1$
        \end{enumerate}
    \end{itemize}
\end{summary}

\subsection{Heapq}
\begin{summary}
\begin{lstlisting}
heapq.heapify(x)
\end{lstlisting}
\begin{itemize}
    \item Transforms a list \texttt{x} into a valid min-heap in-place.
    \item \textbf{Arguments:} \texttt{x}: list to be heapified.
\end{itemize}

\begin{lstlisting}
heapq.heappush(heap, item)
\end{lstlisting}
\begin{itemize}
    \item Inserts \texttt{item} into \texttt{heap} while maintaining the heap invariant.
    \item \textbf{Arguments:} \texttt{heap}: list representing a heap; \texttt{item}: element to insert.
\end{itemize}

\begin{lstlisting}
heapq.heappop(heap)
\end{lstlisting}
\begin{itemize}
    \item Removes and returns the smallest element from the heap.
    \item \textbf{Arguments:} \texttt{heap}: non-empty list representing a valid heap.
\end{itemize}

\begin{lstlisting}
heapq.heappushpop(heap, item)
\end{lstlisting}
\begin{itemize}[noitemsep]
    \item Pushes \texttt{item} onto the heap, then pops and returns the smallest element.
    \item \textbf{Arguments:} \texttt{heap}: valid heap; \texttt{item}: element to insert.
\end{itemize}
    
\begin{lstlisting}
heapq.heapreplace(heap, item)
\end{lstlisting}
\begin{itemize}
    \item Pops and returns the smallest element, then inserts \texttt{item} into the heap.
    \item \textbf{Arguments:} \texttt{heap}: non-empty valid heap; \texttt{item}: element to insert.
\end{itemize}

\begin{lstlisting}
heapq.nlargest(n, iterable)
\end{lstlisting}
\begin{itemize}
    \item Returns the \texttt{n} largest elements from \texttt{iterable} in descending order.
    \item \textbf{Arguments:} \texttt{n}: number of elements; \texttt{iterable}: list or other iterable.
\end{itemize}
    
\begin{lstlisting}
heapq.nsmallest(n, iterable)
\end{lstlisting}
\begin{itemize}[noitemsep]
    \item Returns the \texttt{n} smallest elements from \texttt{iterable} in ascending order.
    \item \textbf{Arguments:} \texttt{n}: number of elements; \texttt{iterable}: list or other iterable.
\end{itemize}        
\end{summary}
\newpage

\begin{algo}
\begin{lstlisting}
class MinHeap:
    def __init__(self):
        self.heap = []

    def parent(self, i):
        return (i - 1) // 2

    def left(self, i):
        return 2 * i + 1

    def right(self, i):
        return 2 * i + 2

    def insert(self, key):
        self.heap.append(key)
        i = len(self.heap) - 1
        while i != 0 and self.heap[self.parent(i)] > self.heap[i]:
            self.heap[i], self.heap[self.parent(i)] = self.heap[self.parent(i)], self.heap[i]
            i = self.parent(i)

    def heapify(self, i):
        smallest = i
        l = self.left(i)
        r = self.right(i)

        if l < len(self.heap) and self.heap[l] < self.heap[smallest]:
            smallest = l
        if r < len(self.heap) and self.heap[r] < self.heap[smallest]:
            smallest = r

        if smallest != i:
            self.heap[i], self.heap[smallest] = self.heap[smallest], self.heap[i]
            self.heapify(smallest)

    def extract_min(self):
        if not self.heap:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()

        root = self.heap[0]
        self.heap[0] = self.heap.pop()
        self.heapify(0)
        return root

    def get_min(self):
        return self.heap[0] if self.heap else None
\end{lstlisting}
        
\end{algo}
\newpage

\subsubsection{Operations}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Operation} & \textbf{Time Complexity} \\
            \midrule
            Insert & $O(\log n)$ \\
            \midrule
            Extract Min & $O(\log n)$ \\
            \midrule
            Get Min & $O(1)$ \\
            \midrule
            Heapify & $O(n)$ \\
            \midrule
            Build Heap & $O(n)$ \\
            \midrule
            Search & $O(n)$ \\
            \midrule
            Delete & $O(n)$ \\
            \midrule
            Heap Sort & $O(n \log n)$ \\
        \end{tabular}
    \end{center}
\end{summary}
\newpage

\subsubsection{Common Problem}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description} \\
            \midrule
            703. Kth Largest Element in a Stream & Design a class to find the kth largest element in a stream of numbers. \\
            \multicolumn{2}{p{\linewidth}}{
                    \begin{itemize}
                        \item Implement a heap that keeps track of the k largest elements using a min-heap so that the kth largest element is always at the root. 
                        \item \textbf{Process:}
                        \begin{enumerate}
                            \item Change list into heap. If more than $k$ elements, pop until only $k$ elements remain.
                            \item Add: Push new element into heap. If size exceeds $k$, pop the smallest element. Return the root.
                        \end{enumerate}
                    \end{itemize}
                } \\
            \midrule
            1046. Last Stone Weight & You are given an array of integers. \\
            & Each integer represents the weight of a stone. \\
            \multicolumn{2}{p{\linewidth}}{
                    \begin{itemize}
                        \item Convert the list into a max-heap using heapq with negation. 
                        \item While there are at least 1 stone in heap:
                        \begin{itemize}
                            \item If they are equal, both stones are destroyed. If not, new stone is created and pushed back into the heap.
                        \end{itemize}
                        \item Return the weight of the last remaining stone or 0 if there are no stones left.
                    \end{itemize}
                } \\
            \midrule
        \end{tabular}
    \end{center}
\end{summary}


\subsubsection{Priority Queue}
\begin{algo}
    
\end{algo}