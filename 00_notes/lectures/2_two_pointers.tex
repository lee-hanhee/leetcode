\subsection{When to Use?}
\begin{summary}
    \begin{itemize}
        \item If we need to find a pair of elements that satisfy a condition.
        \item If we need to find a subarray that satisfies a condition.
    \end{itemize}
\end{summary}

\subsection{Slow and Fast Pointers}
\begin{algo}
    \begin{enumerate}
        \item 
    \end{enumerate}
\end{algo}

\subsubsection{Common Problems}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            \midrule
            15. 3Sum & Given an array of integers, return all the triplets \\
            & [nums[i], nums[j], nums[k]] s.t. i != j, i != k, and j != k. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item \textbf{Tricks:}
                \end{itemize}
            } \\
            \midrule
            125. Valid Palindrome & Given a string, determine if it is a palindrome, \\
            & considering only alphanumeric characters and ignoring cases. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item \texttt{s\_new = ''.join(char.lower() for char in s if char.isalnum())} to remove non-alphanumeric and lowercase. 
                    \item Use front and back pointers. If they not equal, return False. If equal move both pointers.
                \end{itemize}
            } \\
            \midrule
            167. Two Sum II - Input array is sorted & Given an array of integers that is already sorted in ascending order, \\
            & find two numbers such that they add up to a target. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Use front and back pointers. If > target, move back pointer left. If < target, move front pointer right.
                \end{itemize}
            } \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
\newpage

\subsection{Left and Right Pointers}
\begin{algo}
    \begin{enumerate}
        \item Initialize two pointers. Some common choices:
        \begin{itemize}
            \item One at the front and one at the back of the array.
            \item Both at the front of the array.
            \item Both at the back of the array.
        \end{itemize}
    \end{enumerate}
\end{algo}
\newpage

\subsubsection{Common Problems}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            \midrule
            15. 3Sum & Given an array of integers, return all the triplets \\
            & [nums[i], nums[j], nums[k]] s.t. i != j, i != k, and j != k. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item \textbf{Tricks:}
                \end{itemize}
            } \\
            \midrule
            125. Valid Palindrome & Given a string, determine if it is a palindrome, \\
            & considering only alphanumeric characters and ignoring cases. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item \texttt{s\_new = ''.join(char.lower() for char in s if char.isalnum())} to remove non-alphanumeric and lowercase. 
                    \item Use front and back pointers. If they not equal, return False. If equal move both pointers.
                \end{itemize}
            } \\
            \midrule
            167. Two Sum II - Input array is sorted & Given an array of integers that is already sorted in ascending order, \\
            & find two numbers such that they add up to a target. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Use front and back pointers. If > target, move back pointer left. If < target, move front pointer right.
                \end{itemize}
            } \\
            \midrule
            11. Container With Most Water & Given n non-negative integers a1, a2, ..., an, where each represents \\
            & a point at coordinate (i, ai). \\
            & n vertical lines are drawn such that the two endpoints of line i is at \\
            & (i, ai) and (i, 0). \\
            & Find two lines, which together with x-axis forms a container, \\
            & such that the container contains the most water. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item \textbf{Initialization:}
                    \begin{itemize}
                        \item Set \texttt{left = 0}, \texttt{right = len(height) - 1} to have the width as large as possible.
                        \item Initialize \texttt{maxWater = 0}.
                    \end{itemize}
                
                    \item \textbf{Water Area Calculation:} Define helper function \texttt{amtWater(height, left, right)}:
                    \begin{itemize}
                        \item Compute \texttt{height = min(height[left], height[right])}.
                        \item Compute \texttt{width = right - left}.
                        \item Return \texttt{height * width}.
                    \end{itemize}
                
                    \item \textbf{Two-Pointer Strategy:} \textbf{While} \texttt{left <= right}:
                    \begin{itemize}
                        \item Compute area between \texttt{left} and \texttt{right}, update \texttt{maxWater}.
                        \item Move the pointer at the shorter line inward:
                        \begin{itemize}
                            \item If \texttt{height[left] <= height[right]}, increment \texttt{left}.
                            \item Else, decrement \texttt{right}.
                        \end{itemize}
                    \end{itemize}
                \end{itemize}                
            } \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
\newpage

\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            \midrule
            42. Trapping Rain Water & Given n non-negative integers representing an elevation map \\
            & where the width of each bar is 1, compute how much water it can trap \\
            & after raining. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item \textbf{Initialization:} If \texttt{height} is empty, return 0.
                    \begin{itemize}
                        \item Set two pointers: \texttt{l = 0}, \texttt{r = len(height) - 1}.
                        \item Initialize \texttt{leftMax = height[l]}, \texttt{rightMax = height[r]}, \texttt{res = 0}.
                    \end{itemize}
                
                    \item \textbf{Two-Pointer Traversal:} \textbf{While} \texttt{l < r}:
                    \begin{itemize}
                        \item If \texttt{leftMax < rightMax}:
                        \begin{itemize}
                            \item Increment \texttt{l}. Update \texttt{leftMax = max(leftMax, height[l])}.
                            \item Accumulate water: \texttt{res += leftMax - height[l]}.
                        \end{itemize}
                        \item Else:
                        \begin{itemize}
                            \item Decrement \texttt{r}. Update \texttt{rightMax = max(rightMax, height[r])}.
                            \item Accumulate water: \texttt{res += rightMax - height[r]}.
                        \end{itemize}
                    \end{itemize}
                    \item \textbf{Intuition:} 
                    \begin{itemize}
                        \item Always move the pointer at the side with the smaller maximum, since the water trapped at that point depends on the limiting side.
                        \item The water accumulated for a column is determined by the height of the column minus the min of the maximum heights on both sides.
                    \end{itemize}
                \end{itemize}                
            } \\ 
            \midrule
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}


