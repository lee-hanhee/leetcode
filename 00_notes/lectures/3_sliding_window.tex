\subsection{Fixed Sliding Window}
\begin{summary}
    \begin{itemize}
        \item Find a subarray/substring of a fixed size that satisfies a condition.
        \item Find the maximum or minimum of a subarray of a fixed size.
    \end{itemize}
\end{summary}

\begin{algo}
    \begin{lstlisting}
initialize window_sum = 0
initialize max_result (or other required value)

# Set up initial window
for i in range(0, k):
    window_sum += arr[i]

max_result = window_sum # Initialize result

# Slide the window 
for i in range(k, n):
    window_sum += arr[i] - arr[i - k] # Add new element and remove 1st element of prev window
    max_result = max(max_result, window_sum) (or other computation)

return max_result (or other required value)
    \end{lstlisting}
\end{algo}

\subsubsection{Common Problems}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            \midrule
            643. Maximum Average Subarray I & Given an integer array nums and an integer k, \\
            & return the maximum average value of a subarray of length k. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item Follow template. 
                \end{itemize}
            } \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
\newpage

\subsection{Dynamic Sliding Window}
\begin{summary}
    \begin{itemize}
        \item Find longest or shortest subarray/substring that satisfies a condition.
    \end{itemize}
\end{summary}

\begin{algo}
\begin{lstlisting}
initialize left = 0
initialize window_state (sum, count, frequency map, etc.)
initialize min_or_max_result

for right in range(n):
    update window_state to include arr[right] # Expand the window

    while window_state violates the condition:
        update min_or_max_result (if needed)
        update window_state to exclude arr[left] # Shrink the window
        move left pointer forward

return min_or_max_result
\end{lstlisting}
\end{algo}

\subsubsection{Common Problems}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            \midrule
            121. Best Time to Buy and Sell Stock & Given an array where the ith element is the price of a given stock \\ 
            & on day i, find the maximum profit you can achieve. \\ 
            & You may not engage in multiple transactions. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item \textbf{Buy low, sell high principle}
                    \begin{itemize}
                        \item Use left = buy and right = sell, initialized at 0, 1. 
                        \item If price[right] >= price[left], update max profit. Move right pointer since we can still sell for a profit.
                        \item If price[right] < price[left], move left pointer since we need to find a lower price to buy.
                        \item Continue until right pointer reaches the end of the array.
                    \end{itemize}
                \end{itemize}
            } \\
            \midrule
            3. Longest Substring Without Repeating Characters & Given a string s, find the length of the longest substring \\
            & without repeating characters. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item \textbf{Init:} Follow template and use frequency map of chars for window\_state.
                    \item \textbf{While:} If a char is repeated, move left pointer to right by 1 until current char is unique. 
                    \item \textbf{Change:} Compare substring length outside of while with \texttt{max\_res = max(max\_res, right - left + 1)}.
                \end{itemize}
            } \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}