\subsection{Interviewer Considerations}
\begin{notes}
    \begin{itemize}
        \item How did the candidate \textbf{analyze} the problem?
        \item Did the candidate miss any special or \textbf{edge} cases?
        \item Did the candidate approach the problem \textbf{methodically} and logically?
        \item Does the candidate have a strong foundation in basic computer science \textbf{concepts}?
        \item Did the candidate produce \textbf{working code}? Did the candidate \textbf{test} the code?
        \item Is the candidate's code clean and easy to read and \textbf{maintain}?
        \item Can the candidate \textbf{explain} their ideas clearly?
    \end{itemize}    
\end{notes}

\subsection{Steps for Success During the Technical Interview}
\begin{summary}
    \begin{enumerate}
        \item \textbf{Clarify the question}
        \begin{enumerate}
            \item Understand what the question is asking and gather example inputs and outputs.
            \item Clarify constraints such as:
            \begin{enumerate}
                \item Can numbers be negative or repeated?
                \item Are values sorted or do we need to sort them?
                \item Can we assume input validity?
            \end{enumerate}
            \item Asking clarifying questions shows communication skills and prevents missteps.
        \end{enumerate}

        \item \textbf{Design a solution}
        \begin{enumerate}
            \item Avoid immediate coding; propose an initial approach and refine it.
            \item Analyze the algorithm's time and space complexity.
            \item Consider and address edge cases.
            \item Think aloud to demonstrate logical reasoning and collaboration.
            \item Discuss non-optimal ideas to show your thought process.
        \end{enumerate}

        \item \textbf{Write your code}
        \begin{enumerate}
            \item Structure the solution using helper functions.
            \item Confirm API details when uncertain.
            \item Use your strongest programming language and full syntax.
            \item Write complete, working code—not pseudocode.
        \end{enumerate}

        \item \textbf{Test your code}
        \begin{enumerate}
            \item Validate your solution with 1–2 example test cases.
            \item Walk through each line using inputs.
            \item Do not assume correctness—prove it through testing.
            \item Discuss any further optimizations and their trade-offs.
        \end{enumerate}
    \end{enumerate}
\end{summary}

\subsection{Common Mistakes to Avoid}
\begin{warning}
    \begin{enumerate}
        \item Starting to code without clarifying the problem.
        \item Failing to write or discuss sample inputs and outputs.
        \item Using pseudocode instead of fully functional code.
        \item Misunderstanding the problem or optimizing prematurely.
    \end{enumerate}
\end{warning}
\newpage

\subsection{Syntax}
\begin{summary}

    \begin{enumerate}
        \item \texttt{dict.items()}
        \begin{itemize}
            \item Returns a view object that displays a list of a dictionary's key-value tuple pairs.
        \end{itemize}
        \item \texttt{sorted(iterable,\ key=...,\ reverse=...)}
        \begin{itemize}
            \item \texttt{iterable}: The sequence or collection (e.g., list, dictionary view) to be sorted.
            \item \texttt{key=...}: A function that extracts a comparison key from each element. Sorting is performed based on the result of this function.
            \begin{itemize}
                \item \texttt{key=lambda x: x[0]}: Sort by the first element of each tuple.
                \item \texttt{key=lambda x: x[1]}: Sort by the second element of each tuple.
            \end{itemize}
            \item \texttt{reverse=...}: A boolean value. If \texttt{True}, sorted in descending order; otherwise, sorted in ascending order (default is \texttt{False}).
        \end{itemize}
        \item \texttt{collections.Counter(iterable)}
        \begin{itemize}
            \item Counts the frequency of each unique element in \texttt{iterable} and returns a dictionary-like object.
            \item \textbf{Arguments:}
            \begin{itemize}
                \item \texttt{iterable}: a sequence (e.g., list, string) or any iterable containing hashable elements.
            \end{itemize}
        \end{itemize}
    \end{enumerate}

\end{summary}
\newpage

\subsection{Big-O Cheat Sheet}
\begin{summary}
    \begin{center}
        \begin{tabular}{lll}
            \toprule
            \textbf{Data Structure} & \textbf{Average | Worst TC (Access/Search/Insert/Delete)} & \textbf{SC (Worst)} \\
            \midrule
            Array & $\Theta(1)/\Theta(n)/\Theta(n)/\Theta(n) \, | \, O(1)/O(n)/O(n)/O(n)$ & $O(n)$ \\
            & & \\
            Stack & $\Theta(n)/\Theta(n)/\Theta(1)/\Theta(1) \, | \, O(n)/O(n)/O(1)/O(1)$ & $O(n)$ \\
            & & \\
            Queue & $\Theta(n)/\Theta(n)/\Theta(1)/\Theta(1) \, | \, O(n)/O(n)/O(1)/O(1)$ & $O(n)$ \\
            & & \\
            Singly-Linked List & $\Theta(n)/\Theta(n)/\Theta(1)/\Theta(1) \, | \, O(n)/O(n)/O(1)/O(1)$ & $O(n)$ \\
            & & \\
            Doubly-Linked List & $\Theta(n)/\Theta(n)/\Theta(1)/\Theta(1) \, | \, O(n)/O(n)/O(1)/O(1)$ & $O(n)$ \\
            & & \\
            Skip List & $\Theta(\log n)/\Theta(\log n)/\Theta(\log n)/\Theta(\log n) \, | \, O(n)/O(n)/O(n)/O(n)$ & $O(n \log n)$ \\
            & & \\
            Hash Table & N/A / $\Theta(1)/\Theta(1)/\Theta(1) \, | \, N/A/O(n)/O(n)/O(n)$ & $O(n)$ \\
            & & \\
            Binary Search Tree & $\Theta(\log n)/\Theta(\log n)/\Theta(\log n)/\Theta(\log n) \, | \, O(n)/O(n)/O(n)/O(n)$ & $O(n)$ \\
            & & \\
            Cartesian Tree & N/A / $\Theta(\log n)/\Theta(\log n)/\Theta(\log n) \, | \, N/A/O(n)/O(n)/O(n)$ & $O(n)$ \\
            & & \\
            B-Tree & $\Theta(\log n)/\Theta(\log n)/\Theta(\log n)/\Theta(\log n) \, | \, O(\log n)/O(\log n)/O(\log n)/O(\log n)$ & $O(n)$ \\
            & & \\
            Red-Black Tree & $\Theta(\log n)/\Theta(\log n)/\Theta(\log n)/\Theta(\log n) \, | \, O(\log n)/O(\log n)/O(\log n)/O(\log n)$ & $O(n)$ \\
            & & \\
            Splay Tree & N/A / $\Theta(\log n)/\Theta(\log n)/\Theta(\log n) \, | \, N/A/O(\log n)/O(\log n)/O(\log n)$ & $O(n)$ \\
            & & \\
            AVL Tree & $\Theta(\log n)/\Theta(\log n)/\Theta(\log n)/\Theta(\log n) \, | \, O(\log n)/O(\log n)/O(\log n)/O(\log n)$ & $O(n)$ \\
            & & \\
            KD Tree & $\Theta(\log n)/\Theta(\log n)/\Theta(\log n)/\Theta(\log n) \, | \, O(n)/O(n)/O(n)/O(n)$ & $O(n)$ \\
            \bottomrule
        \end{tabular}
    \end{center}        
\end{summary}
\newpage

\subsection{Array Sorting Algorithms}
\begin{summary}
    \begin{center}
        \begin{tabular}{lll}
            \toprule
            \textbf{Algorithm} & \textbf{Time Complexity (Best | Average | Worst)} & \textbf{Space Complexity (Worst)} \\
            \midrule
            Quicksort & $\Omega(n \log n)\,|\,\Theta(n \log n)\,|\,O(n^2)$ & $O(\log n)$ \\[1ex]
            Mergesort & $\Omega(n \log n)\,|\,\Theta(n \log n)\,|\,O(n \log n)$ & $O(n)$ \\[1ex]
            Timsort & $\Omega(n)\,|\,\Theta(n \log n)\,|\,O(n \log n)$ & $O(n)$ \\[1ex]
            Heapsort & $\Omega(n \log n)\,|\,\Theta(n \log n)\,|\,O(n \log n)$ & $O(1)$ \\[1ex]
            Bubble Sort & $\Omega(n)\,|\,\Theta(n^2)\,|\,O(n^2)$ & $O(1)$ \\[1ex]
            Insertion Sort & $\Omega(n)\,|\,\Theta(n^2)\,|\,O(n^2)$ & $O(1)$ \\[1ex]
            Selection Sort & $\Omega(n^2)\,|\,\Theta(n^2)\,|\,O(n^2)$ & $O(1)$ \\[1ex]
            Tree Sort & $\Omega(n \log n)\,|\,\Theta(n \log n)\,|\,O(n^2)$ & $O(n)$ \\[1ex]
            Shell Sort & $\Omega(n \log n)\,|\,\Theta(n(\log n)^2)\,|\,O(n(\log n)^2)$ & $O(1)$ \\[1ex]
            Bucket Sort & $\Omega(n + k)\,|\,\Theta(n + k)\,|\,O(n^2)$ & $O(n)$ \\[1ex]
            Radix Sort & $\Omega(nk)\,|\,\Theta(nk)\,|\,O(nk)$ & $O(n + k)$ \\[1ex]
            Counting Sort & $\Omega(n + k)\,|\,\Theta(n + k)\,|\,O(n + k)$ & $O(k)$ \\[1ex]
            Cubesort & $\Omega(n)\,|\,\Theta(n \log n)\,|\,O(n \log n)$ & $O(n)$ \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}