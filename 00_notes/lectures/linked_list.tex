\begin{summary}
    Data structure for storing objects in linear order. 
    \begin{itemize}
        \item \textbf{Object:} Data and a pointer to the next object. 
    \end{itemize}    
\end{summary}

\subsection{When to Use?}
\begin{summary}
    \begin{itemize}
        \item Implement other DS: stacks, queues, hash tables. 
        \item Dynamic memory allocation. 
    \end{itemize}
\end{summary}

\subsection{Singly Linked List}
\begin{algo}
\begin{lstlisting}
class Node:
    def __init__(self, data):
        self.data = data  # Value stored in the node
        self.next = None  # Pointer to the next node

class SinglyLinkedList:
    def __init__(self,data):
        self.head = Node(data)  # Head of the list

    def operations(self):
        pass
\end{lstlisting}
        
\end{algo}

\subsection{Operations}
\begin{summary}
    \begin{center}
        \begin{tabular}{lc}
            \toprule
            \textbf{Operation} & \textbf{Time Complexity (WC)} \\
            \midrule
            Search & $O(n)$ \\
            Insert & $O(n)$ \\
            Delete & $O(n)$ \\
            Access & $O(n)$ \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
\newpage

\subsection{Doubly Linked List}
\begin{algo}
\begin{lstlisting}
class Node:
    def __init__(self, data):
        self.data = data  # Value stored in the node
        self.next = None  # Pointer to the next node
        self.prev = None  # Pointer to the previous node

class DoublyLinkedList:
    def __init__(self,data):
        self.head = Node(data)  # Head of the list

    def operations(self):
        pass
\end{lstlisting}
\end{algo}

\subsection{Operations}
\begin{summary}
    \begin{center}
        \begin{tabular}{lc}
            \toprule
            \textbf{Operation} & \textbf{Time Complexity (WC)} \\
            \midrule
            Search & $O(n)$ \\
            Insert & $O(n)$ \\
            Delete & $O(n)$ \\
            Access & $O(n)$ \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
\newpage

\subsection{Circular Linked List}
\begin{algo}
\begin{lstlisting}
class Node:
    def __init__(self, data):
        self.data = data  # Value stored in the node
        self.next = None  # Pointer to the next node

class CircularLinkedList:
    def __init__(self,data):
        self.head = Node(data)  # Head of the list
        self.head.next = self.head  # Point to itself

    def operations(self):
        pass
\end{lstlisting}
\end{algo}  

\subsection{Operations}
\begin{summary}
    \begin{center}
        \begin{tabular}{lc}
            \toprule
            \textbf{Operation} & \textbf{Time Complexity (WC)} \\
            \midrule
            Search & $O(n)$ \\
            Insert & $O(n)$ \\
            Delete & $O(n)$ \\
            Access & $O(n)$ \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
\newpage

\subsection{Common Problems}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            \midrule
                % 206. Reverse Linked List & Given the head of a singly linked list, reverse the list and return the reversed list. \\
                % \multicolumn{2}{p{\linewidth}}{
                %     \begin{itemize}
                %         \item \textbf{Iterative:} 
                %         \begin{itemize}
                %             \item Init: $\underbrace{\text{None}}_{\text{prev}} \rightarrow \underbrace{1}_{\text{cur}} \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5$
                %             \item While loop: 
                %             \begin{itemize}
                %                 \item Temp: $\underbrace{\text{None}}_{\text{prev}} \rightarrow \underbrace{1}_{\text{cur}} \rightarrow \underbrace{2}_{\text{temp}} \rightarrow 3 \rightarrow 4 \rightarrow 5$
                %                 \item Switch link: $\underbrace{\text{None}}_{\text{prev}} \leftarrow \underbrace{1}_{\text{cur}} \rightarrow \underbrace{2}_{\text{temp}} \rightarrow 3 \rightarrow 4 \rightarrow 5$
                %                 \item Swap positions: $\underbrace{1}_{\text{prev = cur}} \rightarrow \underbrace{2}_{\text{cur = temp}} \rightarrow 3 \rightarrow 4 \rightarrow 5$
                %             \end{itemize}
                %         \end{itemize}                        
                %     \end{itemize}
                % } \\
                % \midrule
                21. Merge Two Sorted Lists & Given two sorted linked lists, merge them into one sorted list. \\
                \multicolumn{2}{p{\linewidth}}{
                    \begin{itemize}
                        \item \textbf{Initialize a dummy head:} 
                        \begin{itemize}
                            \item \texttt{dummy = ListNode()}: Placeholder node to simplify edge case handling. 
                            \item \texttt{current = dummy}: Build the merged list step-by-step.
                        \end{itemize}
                    
                        \item \textbf{Iterate through both lists while neither is empty:} 
                        \begin{itemize}
                            \item \textbf{Compare current nodes:}
                            \begin{itemize}
                                \item If \texttt{list1.val <= list2.val}, attach \texttt{list1}'s node to \texttt{current.next}, and move \texttt{list1} forward. Otherwise, do the same for \texttt{list2}.
                            \end{itemize}
                            \item Move the \texttt{current} pointer forward.
                        \end{itemize}
                    
                        \item \textbf{Attach remaining nodes (if any):} After the loop, only one of \texttt{list1} or \texttt{list2} may still have nodes left. 
                        \begin{itemize}
                            \item \texttt{current.next = list1 if list1 else list2} ensures the remainder is attached.
                        \end{itemize}
                    
                        \item \textbf{Return the merged list:} \texttt{return dummy.next} returns actual start of the merged list.
                        \begin{itemize}
                        \item \textbf{Visualization:}
                        \begin{itemize}
                            \item \textbf{Initial state:}
                            
                            \begin{itemize}
                                \item List1: $\underbrace{1}_{\text{list1}} \rightarrow 2 \rightarrow 4$
                                \item List2: $\underbrace{1}_{\text{list2}} \rightarrow 3 \rightarrow 4$
                                \item Merged List: $\underbrace{\text{dummy}}_{\text{start}} \rightarrow$
                            \end{itemize}
                        
                            \item \textbf{Step 1: Compare list1 and list2 (1 $\leq$ 1), take list1}
                            
                            \begin{itemize}
                                \item dummy $\rightarrow \underbrace{1}_{\text{current}} \rightarrow$
                                \item list1 $\rightarrow \underbrace{2}_{\text{list1}} \rightarrow 4$
                                \item list2 unchanged: $\underbrace{1}_{\text{list2}} \rightarrow 3 \rightarrow 4$
                            \end{itemize}
                        
                            \item \textbf{Step 2: Compare 2 and 1 (2 $>$ 1), take list2}
                            
                            \begin{itemize}
                                \item dummy $\rightarrow 1 \rightarrow \underbrace{1}_{\text{current}} \rightarrow$
                                \item list1 remains: $\underbrace{2}_{\text{list1}} \rightarrow 4$
                                \item list2 $\rightarrow \underbrace{3}_{\text{list2}} \rightarrow 4$
                            \end{itemize}
                        \end{itemize}
                        \end{itemize}                        
                    \end{itemize}                    
                } \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
\newpage

\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            \midrule
                141. Linked List Cycle & Given a linked list, determine if it has a cycle in it. \\
                \multicolumn{2}{p{\linewidth}}{
                    \begin{itemize}
                        \item \textbf{Floyd's Cycle Detection Algorithm:} 
                        \begin{itemize}
                            \item Use two pointers (slow and fast) to traverse the list 
                            \item If they meet, a cycle exists. 
                        \end{itemize}
                        \item \textbf{While Condition:} While fast and fast.next are not None b/c fast moves twice as fast so will reach the end first if no cycle.
                        \begin{itemize}
                            \item \texttt{fast}: Ensures \texttt{fast} is not \texttt{None}, so \texttt{fast.next} is safe.
                            \item \texttt{fast.next}: Ensures \text{tt{fast.next}} is not \texttt{None}, so \texttt{fast.next.next} is safe.
                        \end{itemize}                        
                    \end{itemize}
                } \\
                \midrule
                143. Reorder List & Given a linked list, reorder it in a specific pattern. \\
                & Specifically, the pattern is to rearrange the list s.t. \\
                & the first element is followed by the last element, and so on. \\
                \multicolumn{2}{p{\linewidth}}{
                    \begin{itemize} 
                        \item Find middle of list using slow/fast pointers w/ Floyd's algorithm, but have fast start at 2nd node.
                        \item Reverse the second half of the list using 206. 
                        \item Merge the two halves together.
                    \end{itemize}
                } \\
                \midrule 
                19. Remove Nth Node From End of List & Given a linked list, remove the Nth node from the end of the list. \\
                \multicolumn{2}{p{\linewidth}}{
                    \begin{itemize}
                        \item \textbf{Idea:} Use two pointers (slow and fast) to traverse the list by moving fast pointer N steps ahead. 
                        \begin{itemize}
                            \item \textbf{Conditional:} If fast is None, then this means $N=\text{length of list}$, therefore, remove head by returning head.next.
                        \end{itemize}
                        \item Move both pointers until fast reaches the end. 
                        \begin{itemize}
                            \item Slow pointer will be at the node to be deleted, so store prev node and do appropriate adjustments. 
                        \end{itemize}
                    \end{itemize}
                } \\
                \midrule
                2. Add Two Numbers & Given two non-empty linked lists representing two \\
                & non-negative integers, add the two numbers and return a linked list. \\
                \multicolumn{2}{p{\linewidth}}{
                    \begin{itemize}
                        \item \textbf{Initialize:} Create a dummy node, use \texttt{cur} to traverse as \texttt{cur = dummy}.
                        \begin{itemize}
                            \item Set \texttt{next\_val = 0} to store carry between digit additions.
                        \end{itemize}
                        \item \textbf{Helper Function:} \texttt{add\_two\_nodes(n1, n2, next\_val)}
                        \begin{itemize}
                            \item Extract values: \texttt{val1 = n1.val if n1 else 0}, \texttt{val2 = n2.val if n2 else 0}.
                            \item Compute sum:
                            \begin{itemize}
                                \item \texttt{rem = (val1 + val2 + next\_val) \% 10}
                                \item \texttt{next\_val = (val1 + val2 + next\_val) // 10}.
                            \end{itemize}
                            \item Return updated carry and new node with value \texttt{rem}.
                        \end{itemize}
                        \item \textbf{Traversal Loop:}
                        \begin{itemize}
                            \item Continue while at least one of \texttt{l1}, \texttt{l2} exists or \texttt{next\_val != 0}.
                            \item Call \texttt{add\_two\_nodes(l1, l2, next\_val)} and link result to \texttt{cur.next}.
                            \item Advance \texttt{cur}, and move \texttt{l1}, \texttt{l2} to their next nodes if they exist.
                        \end{itemize}
                    \end{itemize}                    
                } \\
                \midrule
                23. Merge K Sorted Lists & Given an array of k linked lists, each list is sorted in ascending order. \\
                & Merge all the lists into one sorted linked list and return it. \\
                \multicolumn{2}{p{\linewidth}}{
                    \begin{itemize}
                        \item \textbf{Initialization:} Create a min-heap \texttt{heap} to store tuples \texttt{(node.val, list\_index, node)}.
                        \begin{itemize}
                            \item Push the head of each non-empty list in \texttt{lists} into the heap.
                            \item Initialize dummy node \texttt{dummy} and pointer \texttt{cur = dummy}.
                        \end{itemize}
                        \item \textbf{Merge Process:} \textbf{While} \texttt{heap} is not empty:
                        \begin{itemize}
                            \item Pop the smallest element \texttt{(min\_val, list\_ind, node)} from the heap.
                            \item Append \texttt{node} to the result list using \texttt{cur.next = node}, then advance \texttt{cur}.
                            \item If \texttt{node.next} exists, push \texttt{(node.next.val, list\_ind, node.next)} into the heap.
                        \end{itemize}
                        \item \textbf{Return Result:} \texttt{return dummy.next} (skipping dummy head).
                    \end{itemize}                    
                } \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
\newpage 

\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            \midrule
            287. Find the Duplicate Number & Given an array of integers, find the duplicate number. \\
            \multicolumn{2}{p{\linewidth}}{
                \begin{itemize}
                    \item \textbf{Phase 1: Cycle Detection (Floyd's Tortoise and Hare)}
                    \begin{itemize}
                        \item Initialize two pointers: \texttt{slow = 0}, \texttt{fast = 0}.
                        \item \textbf{Loop:} Move \texttt{slow = nums[slow]}, \texttt{fast = nums[nums[fast]]}.
                        \item Continue until \texttt{slow == fast}, indicating an intersection point within the cycle.
                    \end{itemize}
                    
                    \item \textbf{Phase 2: Cycle Entrance (Duplicate Finder)}
                    \begin{itemize}
                        \item Initialize a new pointer: \texttt{slow2 = 0}.
                        \item \textbf{Loop:} Move both \texttt{slow = nums[slow]} and \texttt{slow2 = nums[slow2]}.
                        \item When \texttt{slow == slow2}, return the value at that index as the duplicate.
                    \end{itemize}
                
                    \item \textbf{Rationale:}
                    \begin{itemize}
                        \item Each number is a pointer to the next index; repeated values form a cycle.
                        \item Detecting the start of the cycle identifies the duplicate.
                    \end{itemize}
                \end{itemize}                
            } \\
        \end{tabular}
    \end{center}
\end{summary}
