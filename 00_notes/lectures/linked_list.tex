\begin{summary}
    Data structure for storing objects in linear order. 
    \begin{itemize}
        \item \textbf{Object:} Data and a pointer to the next object. 
    \end{itemize}    
\end{summary}

\subsection{When to Use?}
\begin{summary}
    \begin{itemize}
        \item Implement other DS: stacks, queues, hash tables. 
        \item Dynamic memory allocation. 
    \end{itemize}
\end{summary}

\subsection{Singly Linked List}
\begin{algo}
\begin{lstlisting}[language=Python, caption=Singly Linked List in Python]
class Node:
    def __init__(self, data):
        self.data = data  # Value stored in the node
        self.next = None  # Pointer to the next node

class SinglyLinkedList:
    def __init__(self,data):
        self.head = Node(data)  # Head of the list

    def operations(self):
        pass
\end{lstlisting}
        
\end{algo}
\begin{summary}
    \begin{center}
        \begin{tabular}{lc}
            \toprule
            \textbf{Operation} & \textbf{Time Complexity} \\
            \midrule
            Search & $O(n)$ \\
            Insert & $O(1)$ \\
            Delete & $O(1)$ \\
            Access & $O(n)$ \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}

\subsection{Operations}
\newpage

\subsection{Common Problems}
\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            \midrule
                206. Reverse Linked List & Given the head of a singly linked list, reverse the list and return the reversed list. \\
                \multicolumn{2}{p{\linewidth}}{
                    \begin{itemize}
                        \item \textbf{Iterative:} 
                        \begin{itemize}
                            \item Init: $\underbrace{\text{None}}_{\text{prev}} \rightarrow \underbrace{1}_{\text{cur}} \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5$
                            \item While loop: 
                            \begin{itemize}
                                \item Temp: $\underbrace{\text{None}}_{\text{prev}} \rightarrow \underbrace{1}_{\text{cur}} \rightarrow \underbrace{2}_{\text{temp}} \rightarrow 3 \rightarrow 4 \rightarrow 5$
                                \item Switch link: $\underbrace{\text{None}}_{\text{prev}} \leftarrow \underbrace{1}_{\text{cur}} \rightarrow \underbrace{2}_{\text{temp}} \rightarrow 3 \rightarrow 4 \rightarrow 5$
                                \item Swap positions: $\underbrace{1}_{\text{prev = cur}} \rightarrow \underbrace{2}_{\text{cur = temp}} \rightarrow 3 \rightarrow 4 \rightarrow 5$
                            \end{itemize}
                        \end{itemize}                        
                    \end{itemize}
                } \\
                \midrule
                21. Merge Two Sorted Lists & Given two sorted linked lists, merge them into one sorted list. \\
                \multicolumn{2}{p{\linewidth}}{
                    \begin{itemize}
                        \item \textbf{Initialize a dummy head:} 
                        \begin{itemize}
                            \item \texttt{dummy = ListNode()}: Placeholder node to simplify edge case handling. 
                            \item \texttt{current = dummy}: Build the merged list step-by-step.
                        \end{itemize}
                    
                        \item \textbf{Iterate through both lists while neither is empty:} 
                        \begin{itemize}
                            \item \textbf{Compare current nodes:}
                            \begin{itemize}
                                \item If \texttt{list1.val <= list2.val}, attach \texttt{list1}'s node to \texttt{current.next}, and move \texttt{list1} forward. Otherwise, do the same for \texttt{list2}.
                            \end{itemize}
                            \item Move the \texttt{current} pointer forward.
                        \end{itemize}
                    
                        \item \textbf{Attach remaining nodes (if any):} After the loop, only one of \texttt{list1} or \texttt{list2} may still have nodes left. 
                        \begin{itemize}
                            \item \texttt{current.next = list1 if list1 else list2} ensures the remainder is attached.
                        \end{itemize}
                    
                        \item \textbf{Return the merged list:} \texttt{return dummy.next} returns actual start of the merged list.
                        \begin{itemize}
                        \item \textbf{Visualization:}
                        \begin{itemize}
                            \item \textbf{Initial state:}
                            
                            \begin{itemize}
                                \item List1: $\underbrace{1}_{\text{list1}} \rightarrow 2 \rightarrow 4$
                                \item List2: $\underbrace{1}_{\text{list2}} \rightarrow 3 \rightarrow 4$
                                \item Merged List: $\underbrace{\text{dummy}}_{\text{start}} \rightarrow$
                            \end{itemize}
                        
                            \item \textbf{Step 1: Compare list1 and list2 (1 $\leq$ 1), take list1}
                            
                            \begin{itemize}
                                \item dummy $\rightarrow \underbrace{1}_{\text{current}} \rightarrow$
                                \item list1 $\rightarrow \underbrace{2}_{\text{list1}} \rightarrow 4$
                                \item list2 unchanged: $\underbrace{1}_{\text{list2}} \rightarrow 3 \rightarrow 4$
                            \end{itemize}
                        
                            \item \textbf{Step 2: Compare 2 and 1 (2 $>$ 1), take list2}
                            
                            \begin{itemize}
                                \item dummy $\rightarrow 1 \rightarrow \underbrace{1}_{\text{current}} \rightarrow$
                                \item list1 remains: $\underbrace{2}_{\text{list1}} \rightarrow 4$
                                \item list2 $\rightarrow \underbrace{3}_{\text{list2}} \rightarrow 4$
                            \end{itemize}
                        \end{itemize}
                        \end{itemize}                        
                    \end{itemize}                    
                } \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
\newpage

\begin{summary}
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Problem} & \textbf{Description:} \\
            \midrule
                141. Linked List Cycle & Given a linked list, determine if it has a cycle in it. \\
                \multicolumn{2}{p{\linewidth}}{
                    \begin{itemize}
                        \item \textbf{Floyd's Cycle Detection Algorithm:} 
                        \begin{itemize}
                            \item Use two pointers (slow and fast) to traverse the list 
                            \item If they meet, a cycle exists. 
                        \end{itemize}
                        \item \textbf{While Condition:} While fast and fast.next are not None b/c fast moves twice as fast so will reach the end first if no cycle.
                        \begin{itemize}
                            \item \texttt{fast}: Ensures \texttt{fast} is not \texttt{None}, so \texttt{fast.next} is safe.
                            \item \texttt{fast.next}: Ensures \text{tt{fast.next}} is not \texttt{None}, so \texttt{fast.next.next} is safe.
                        \end{itemize}                        
                    \end{itemize}
                } \\
                \midrule
                143. Reorder List & Given a linked list, reorder it in a specific pattern. \\
                & Specifically, the pattern is to rearrange the list s.t. the first element is followed by \\
                & the last element, and so on. \\
                \multicolumn{2}{p{\linewidth}}{
                    \begin{itemize} 
                        \item Find middle of list using slow/fast pointers w/ Floyd's algorithm, but have fast start at 2nd node.
                        \item Reverse the second half of the list using 206. 
                        \item Merge the two halves together.
                    \end{itemize}
                } \\
                \midrule
            \bottomrule
        \end{tabular}
    \end{center}
\end{summary}

\subsection{Doubly Linked List}
\begin{algo}

\end{algo}

\subsection{Circular Linked List}
\begin{algo}

\end{algo}
\newpage 
